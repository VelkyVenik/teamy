# Teamy

> A lightweight, self-evolving Microsoft Teams chat client for macOS.

Teams uses 300–500 MB RAM just for chat. Teamy replaces that with a native-feeling Nuxt app inside Tauri (~60–100 MB), handles day-to-day messaging, and delegates calls/meetings to Teams Web via deep links. An embedded Claude AI assistant can extend the app at runtime through a plugin system.

---

## Tech Stack

| Layer | Technology | Why |
|-------|-----------|-----|
| Desktop shell | **Tauri v2** | Native WebKit on macOS, ~10 MB binary, no Chromium |
| Runtime | **Bun** | Fast JS/TS runtime, built-in bundler, native speed |
| Framework | **Nuxt 4 + TypeScript** | Full-stack Vue framework, file-based routing, auto-imports |
| UI | **Nuxt UI v3** | Component library built on Reka UI + Tailwind CSS v4 |
| Auth | **nuxt-oidc-auth** | Native OIDC module with built-in Entra ID provider, PKCE, token validation |
| State | **Pinia** | Official Vue/Nuxt state management |
| API | **Microsoft Graph API** | Teams chat, channels, presence, user info |
| AI | **Anthropic Claude API** | Embedded assistant + plugin generation |
| Backend bridge | **Rust (Tauri commands)** | Native macOS APIs: notifications, keychain, filesystem |

---

## Architecture

```
┌──────────────────────────────────────────────────┐
│                  Tauri v2 Shell                   │
│                                                  │
│  ┌──────────────────────────────────────────┐    │
│  │           Nuxt 4 Application             │    │
│  │                                          │    │
│  │  pages/          composables/            │    │
│  │  ├── index.vue   ├── useGraph.ts         │    │
│  │  ├── chat/       ├── usePresence.ts      │    │
│  │  └── settings/   └── useClaude.ts        │    │
│  │                                          │    │
│  │  components/     stores/                 │    │
│  │  ├── chat/       ├── chat.ts             │    │
│  │  ├── channel/    ├── channel.ts          │    │
│  │  └── claude/     └── plugin.ts           │    │
│  │                                          │    │
│  │  server/                                 │    │
│  │  ├── api/auth/   (nuxt-oidc-auth)        │    │
│  │  └── api/graph/  (proxy + cache)         │    │
│  │                                          │    │
│  └──────────────────────┬───────────────────┘    │
│                         │                        │
│  ┌──────────────────────▼───────────────────┐    │
│  │       Plugin Runtime (dynamic JS)         │    │
│  │  ~/.teamy/plugins/                        │    │
│  │  Sandboxed ES modules loaded at runtime   │    │
│  │  Generated by Claude, stored locally      │    │
│  └──────────────────────┬───────────────────┘    │
│                         │                        │
│  ┌──────────────────────▼───────────────────┐    │
│  │      Rust Backend (Tauri Commands)        │    │
│  │  macOS notifications · keychain           │    │
│  │  file system · deep links · system tray   │    │
│  └───────────────────────────────────────────┘    │
└──────────────────────────────────────────────────┘
```

### Key Architectural Decision: Nuxt SSR in Tauri

Nuxt runs as a **local Nitro server** inside Tauri (not SSG). This enables:

- `nuxt-oidc-auth` server routes for OAuth callback handling
- Server API routes as a proxy/cache layer for Graph API
- Full Nuxt feature set (server middleware, API routes, auth)

Tauri connects to the local Nitro server in both dev and production:

- **Dev:** `bun run dev` → Tauri connects to `http://localhost:3000`
- **Prod:** Tauri launches bundled Nitro server → connects to `http://localhost:3000`

---

## Workstreams

The project is split into **6 parallel workstreams**. Each can be developed and tested independently. Integration points are marked with `→ DEPENDS ON`.

---

### WS1: Project Scaffold & Build Pipeline

**Goal:** Tauri v2 + Bun + Nuxt 4 + Nuxt UI project that builds and runs on macOS.

**Tasks:**

1. Initialize Nuxt 4 project with Bun:
   ```bash
   bunx nuxi@latest init teamy
   cd teamy
   bun add @nuxt/ui
   bun add -D @nuxt/icon
   ```

2. Configure `nuxt.config.ts`:
   ```typescript
   export default defineNuxtConfig({
     compatibilityDate: '2025-05-15',
     modules: ['@nuxt/ui', '@nuxt/icon'],
     ssr: false,
     devtools: { enabled: true },
     devServer: { host: '0' },
     vite: {
       clearScreen: false,
       envPrefix: ['VITE_', 'TAURI_'],
       server: { strictPort: true }
     },
     ignore: ['**/src-tauri/**']
   })
   ```

3. Initialize Tauri v2 inside the project:
   ```bash
   bunx @tauri-apps/cli@latest init
   ```

4. Configure `src-tauri/tauri.conf.json`:
   ```json
   {
     "build": {
       "beforeDevCommand": "bun run dev",
       "beforeBuildCommand": "bun run generate",
       "devUrl": "http://localhost:3000",
       "frontendDist": "../.output/public"
     }
   }
   ```

5. Set up app metadata: icon, macOS menu bar, system tray skeleton
6. Verify `bun run tauri dev` launches the app with hot reload
7. Verify `bun run tauri build` produces a `.dmg`

**Output:** Empty shell app that launches on macOS with Nuxt UI default page and system tray icon.

**No dependencies on other workstreams.**

---

### WS2: Authentication (nuxt-oidc-auth + Entra ID)

**Goal:** OIDC login to Microsoft 365 / Entra ID with token management.

**Tasks:**

1. Install and configure nuxt-oidc-auth:
   ```bash
   bun add nuxt-oidc-auth
   ```

2. Add to `nuxt.config.ts`:
   ```typescript
   modules: ['nuxt-oidc-auth', '@nuxt/ui', '@nuxt/icon'],
   oidc: {
     defaultProvider: 'entra',
     providers: {
       entra: {
         redirectUri: 'http://localhost:3000/auth/entra/callback',
         clientId: process.env.NUXT_OIDC_PROVIDERS_ENTRA_CLIENT_ID,
         clientSecret: process.env.NUXT_OIDC_PROVIDERS_ENTRA_CLIENT_SECRET,
         authorizationUrl: `https://login.microsoftonline.com/${process.env.AZURE_TENANT_ID}/oauth2/v2.0/authorize`,
         tokenUrl: `https://login.microsoftonline.com/${process.env.AZURE_TENANT_ID}/oauth2/v2.0/token`,
         scope: ['openid', 'profile', 'User.Read', 'Chat.ReadWrite',
                 'ChannelMessage.Read.All', 'ChannelMessage.Send',
                 'Team.ReadBasic.All', 'Channel.ReadBasic.All',
                 'Presence.Read', 'Presence.Read.All'],
         userNameClaim: 'name',
         validateAccessToken: false, // Graph API tokens can't be validated locally
       }
     },
     session: {
       automaticRefresh: true,
       expirationCheck: true,
     }
   }
   ```

3. Register Azure AD app with these settings:
   - **Platform:** Web application
   - **Redirect URI:** `http://localhost:3000/auth/entra/callback`
   - **API permissions (delegated):** `Chat.ReadWrite`, `ChannelMessage.Read.All`, `ChannelMessage.Send`, `Team.ReadBasic.All`, `Channel.ReadBasic.All`, `User.Read`, `Presence.Read`, `Presence.Read.All`
   - **Client secret:** generate and store in `.env`

4. Create `.env`:
   ```
   NUXT_OIDC_PROVIDERS_ENTRA_CLIENT_ID=<your-client-id>
   NUXT_OIDC_PROVIDERS_ENTRA_CLIENT_SECRET=<your-client-secret>
   AZURE_TENANT_ID=<your-tenant-id>
   NUXT_OIDC_SESSION_SECRET=<random-32-char-string>
   NUXT_OIDC_TOKEN_KEY=<random-32-char-string>
   ```

5. Create auth middleware `middleware/auth.global.ts`:
   ```typescript
   export default defineNuxtRouteMiddleware((to) => {
     const { loggedIn } = useOidcAuth()
     if (!loggedIn.value && to.path !== '/login') {
       return navigateTo('/login')
     }
   })
   ```

6. Create login page with Nuxt UI components
7. Expose auth composable for Graph API token access: `useGraphToken()` that extracts the access token from the OIDC session for Graph API calls

**Output:** `useOidcAuth()` provides `{ loggedIn, user, login, logout, refresh }`. `useGraphToken()` provides the access token for Graph API.

**→ DEPENDS ON:** WS1 (running Tauri app with Nuxt server routes)

---

### WS3: Graph API — Messaging Core

**Goal:** Read and send messages in 1:1 chats, group chats, and team channels.

**Tasks:**

1. **Graph client composable** — `composables/useGraph.ts`:
   - Typed `$fetch` wrapper with auth header injection from `useGraphToken()`
   - Pagination helpers for Graph API `@odata.nextLink`
   - Rate limiting / retry with exponential backoff
   - Error handling with typed Graph API errors

2. **Server API proxy** (optional, for caching) — `server/api/graph/[...path].ts`:
   - Proxies requests to `https://graph.microsoft.com/v1.0/`
   - Adds auth header from session
   - Caches certain responses (team list, channel list) in memory

3. **Chat operations:**
   - `GET /me/chats` — all chats with last message preview, `$expand=lastMessagePreview`
   - `GET /me/chats/{id}/messages` — paginated message history
   - `POST /me/chats/{id}/messages` — send plain text + basic HTML
   - `GET /me/chats/{id}/members` — chat members for group chats

4. **Channel operations:**
   - `GET /me/joinedTeams` — list teams
   - `GET /teams/{id}/channels` — list channels per team
   - `GET /teams/{id}/channels/{id}/messages` — channel messages with `$expand=replies`
   - `POST /teams/{id}/channels/{id}/messages` — send to channel

5. **Real-time updates:**
   - Polling-based for v1: poll `/me/chats` and active chat messages every 5 seconds
   - Use `deltaLink` where Graph API supports it for efficient polling
   - Abstract behind `useRealtimeMessages(chatId)` composable for future WebSocket upgrade

6. **Presence:**
   - `GET /communications/presences` — batch presence for visible contacts
   - `composables/usePresence.ts` with periodic refresh

7. **Message formatting:**
   - Parse incoming HTML messages (Graph API returns HTML)
   - Handle @mentions, emojis, adaptive cards (basic rendering)
   - Sanitize HTML before rendering

8. **Read receipts:**
   - `PATCH /me/chats/{id}/messages/{id}` — mark as read

**Output:** Pinia stores (`stores/chat.ts`, `stores/channel.ts`) and composables (`useChats()`, `useMessages(chatId)`, `useSendMessage()`, `useChannels()`, `usePresence()`).

**→ DEPENDS ON:** WS2 (auth token)

---

### WS4: UI — Chat Interface

**Goal:** Clean, minimal Nuxt UI-based interface for messaging.

**Tasks:**

1. **Layout** — `layouts/default.vue`:
   - Three-panel layout using Nuxt UI's layout primitives
   - Left sidebar: chat/channel list (resizable, collapsible)
   - Center: message thread
   - Right sidebar: Claude panel (toggleable with `Cmd+J`)
   - Use `USlideover` for Claude panel on smaller screens

2. **Chat list** — `components/chat/ChatList.vue`:
   - `UList` with chat items showing avatar, name, last message preview, timestamp
   - `UBadge` for unread count
   - `UInput` with search/filter at the top
   - Separate sections for recent chats, pinned, channels

3. **Message thread** — `components/chat/MessageThread.vue`:
   - Virtual scrolling for long message lists (use `vue-virtual-scroller` or similar)
   - `components/chat/MessageBubble.vue` — sender avatar, name, timestamp, message HTML
   - Reply threading — collapsible thread view
   - Hover actions: reply, react, copy, forward

4. **Compose bar** — `components/chat/ComposeBar.vue`:
   - `UTextarea` with auto-resize
   - Enter to send, Shift+Enter for newline
   - `UButton` send button with loading state
   - File attachment placeholder (v2 feature)

5. **Channel view** — `pages/channel/[teamId]/[channelId].vue`:
   - Channel header with topic, member count using `UBadge`
   - Same message thread component as chat
   - Thread replies in side panel

6. **Presence indicators:**
   - Green/yellow/red `UChip` indicator on `UAvatar` components
   - Real-time updates via `usePresence()`

7. **Notification badges:**
   - Unread count in sidebar items
   - Total unread in system tray icon (via Tauri command)

8. **Settings page** — `pages/settings/index.vue`:
   - `UForm` with sections for notification preferences, appearance, plugin management
   - Dark/light mode toggle (Nuxt UI `useColorMode()`)

9. **Keyboard shortcuts:**
   - `Cmd+K` — quick switch (command palette using `UCommandPalette`)
   - `Cmd+N` — new chat
   - `Cmd+J` — toggle Claude panel
   - `Cmd+,` — settings

10. **Design principles:**
    - No bloat: no app marketplace, no Viva, no Copilot promotions
    - Fast: virtual scrolling, lazy-loaded components
    - Native-feeling: respect macOS conventions, system font, `UApp` with locale

**Output:** Complete chat UI wired to WS3 stores and composables.

**→ DEPENDS ON:** WS1 (scaffold), WS3 (data layer). Can start with mock data while WS3 is in progress.

---

### WS5: Native macOS Integration (Rust)

**Goal:** Tauri Rust commands for native macOS features.

**Tasks:**

1. **Notifications** — `src-tauri/src/commands/notifications.rs`:
   - Use `tauri-plugin-notification` or direct `UNUserNotificationCenter` via objc crate
   - Show notification for new messages: sender name, message preview, click-to-open
   - Expose as Tauri command: `invoke('send_notification', { title, body, chatId })`
   - Click handler: focus Teamy window and navigate to the chat

2. **Keychain** — `src-tauri/src/commands/keychain.rs`:
   - Store/retrieve OIDC session secrets securely via macOS Keychain
   - `invoke('keychain_store', { key, value })`, `invoke('keychain_get', { key })`

3. **Deep links to Teams** — `src-tauri/src/commands/deeplink.rs`:
   - 1:1 call: `https://teams.microsoft.com/l/call/0/0?users={email}`
   - Join meeting: `https://teams.microsoft.com/l/meetup-join/{joinUrl}`
   - Open in default browser via `open::that(url)` (opens Safari)
   - `invoke('open_teams_call', { email })`, `invoke('join_meeting', { joinUrl })`

4. **System tray** — `src-tauri/src/tray.rs`:
   - Tray icon with unread count badge
   - Right-click menu: Show/Hide, Settings, Quit
   - Use `tauri-plugin-positioner` for menu placement

5. **Menu bar** — native macOS menu:
   - Edit menu with standard shortcuts (Cmd+C, Cmd+V, Cmd+A)
   - App menu with Preferences, About, Quit

6. **Auto-launch** — option to start on login via `tauri-plugin-autostart`

7. **Global shortcut** — `Cmd+Shift+T` to toggle Teamy window via `tauri-plugin-global-shortcut`

**Output:** Rust commands callable from frontend via Tauri's `invoke()`. Frontend composable `useTauri()` wrapping all invoke calls with TypeScript types.

**→ DEPENDS ON:** WS1 (Tauri shell)

---

### WS6: Claude AI Integration & Plugin System

**Goal:** Embedded Claude assistant that can generate and load plugins to extend the app at runtime.

#### Part A: Claude Sidebar

1. **Claude chat panel** — `components/claude/ClaudePanel.vue`:
   - Right sidebar, toggle with `Cmd+J`
   - Chat interface using Nuxt UI components (`UTextarea`, message list)
   - Streaming responses via `server/api/claude/chat.post.ts`

2. **Server-side Claude API** — `server/api/claude/chat.post.ts`:
   - Proxies to `api.anthropic.com/v1/messages`
   - Keeps API key server-side (never exposed to frontend)
   - Streaming via SSE

3. **Context injection** — system prompt includes:
   - Current chat/channel name and recent messages (summarized)
   - List of installed plugins and their capabilities
   - Available PluginContext API definition
   - Available Tauri bridge functions

4. **Quick actions** — slash commands or buttons:
   - `/summarize` — summarize unread messages in current chat
   - `/draft` — draft a reply based on conversation context
   - `/translate` — translate selected message
   - `/plugin` — generate a new plugin from description

#### Part B: Plugin Runtime

1. **Plugin format** — each plugin is an ES module in `~/.teamy/plugins/{id}/`:
   ```typescript
   // ~/.teamy/plugins/notification-filter/index.ts
   import type { TeamyPlugin, PluginContext } from '~/.teamy/types/plugin'

   export default {
     id: 'notification-filter',
     name: 'Smart Notifications',
     version: '1.0.0',
     description: 'Only notify for DMs from specific people',

     activate(ctx: PluginContext) {
       ctx.on('message:received', async (msg) => {
         if (msg.chatType === '1:1' && ctx.settings.get('vipList').includes(msg.sender)) {
           await ctx.sendNotification(msg.sender.name, msg.preview)
         }
       })
     },

     deactivate() {}
   } satisfies TeamyPlugin
   ```

2. **PluginContext API:**
   ```typescript
   interface PluginContext {
     // UI registration
     registerSidebarPanel(component: Component): void
     registerMessageAction(label: string, handler: (msg: Message) => void): void
     registerCommand(name: string, description: string, handler: () => void): void

     // Native bridge (via Tauri)
     sendNotification(title: string, body: string): Promise<void>

     // Data access
     graphFetch<T>(path: string, options?: RequestInit): Promise<T>
     storage: PluginStorage  // key-value store per plugin in ~/.teamy/plugins/{id}/data.json

     // Settings
     settings: PluginSettings  // typed settings with UI generation

     // Events
     on(event: 'message:received' | 'chat:switched' | 'presence:changed', handler: Function): void
     off(event: string, handler: Function): void
   }
   ```

3. **Plugin loader** — `composables/usePlugins.ts`:
   - Scans `~/.teamy/plugins/` for plugin directories
   - Dynamic `import()` of each plugin's `index.ts`
   - Manages lifecycle: activate/deactivate
   - Sandboxing: plugins get a scoped PluginContext, no direct DOM access outside registered panels

4. **Plugin manager UI** — `pages/settings/plugins.vue`:
   - List installed plugins with `UTable`
   - Enable/disable toggle per plugin
   - View plugin logs
   - "New Plugin" button → opens Claude panel with plugin generation prompt

#### Part C: Claude → Plugin Generation Flow

1. User says: *"Add native notifications only for DMs from Engineering team"*
2. Claude receives the PluginContext API definition + user request
3. Claude generates plugin source code (index.ts + manifest)
4. Teamy saves to `~/.teamy/plugins/dm-filter/`
5. Plugin loader picks it up, activates it
6. User sees it in plugin manager, can inspect/edit/disable/delete

**Output:** Working Claude sidebar + plugin runtime + 3 example plugins:
- `notification-filter` — customizable notification rules
- `message-translator` — translate messages via Claude API
- `unread-summarizer` — summarize unread messages on demand

**→ DEPENDS ON:** WS1 (scaffold), WS3 (graph client for plugin context), WS5 (Tauri commands for notifications)

---

## File Structure

```
teamy/
├── src-tauri/                    # Rust backend (Tauri v2)
│   ├── src/
│   │   ├── main.rs
│   │   ├── lib.rs
│   │   └── commands/
│   │       ├── notifications.rs
│   │       ├── keychain.rs
│   │       ├── deeplink.rs
│   │       └── tray.rs
│   ├── Cargo.toml
│   ├── tauri.conf.json
│   └── icons/
├── app/                          # Nuxt 4 app directory
│   ├── pages/
│   │   ├── index.vue             # Main chat view
│   │   ├── login.vue             # Login page
│   │   ├── chat/
│   │   │   └── [chatId].vue      # Individual chat
│   │   ├── channel/
│   │   │   └── [teamId]/
│   │   │       └── [channelId].vue
│   │   └── settings/
│   │       ├── index.vue
│   │       └── plugins.vue
│   ├── components/
│   │   ├── chat/
│   │   │   ├── ChatList.vue
│   │   │   ├── ChatThread.vue
│   │   │   ├── MessageBubble.vue
│   │   │   └── ComposeBar.vue
│   │   ├── channel/
│   │   │   ├── ChannelList.vue
│   │   │   └── ChannelHeader.vue
│   │   ├── claude/
│   │   │   ├── ClaudePanel.vue
│   │   │   └── PluginManager.vue
│   │   └── layout/
│   │       ├── AppSidebar.vue
│   │       └── MainLayout.vue
│   ├── composables/
│   │   ├── useGraph.ts           # Graph API client
│   │   ├── useGraphToken.ts      # Extract token from OIDC session
│   │   ├── useChats.ts           # Chat list & operations
│   │   ├── useMessages.ts        # Messages for a chat
│   │   ├── useChannels.ts        # Teams & channels
│   │   ├── usePresence.ts        # User presence
│   │   ├── useClaude.ts          # Claude API interaction
│   │   ├── usePlugins.ts         # Plugin loader & manager
│   │   └── useTauri.ts           # Typed Tauri invoke wrapper
│   ├── stores/
│   │   ├── chat.ts               # Pinia store for chats
│   │   ├── channel.ts            # Pinia store for channels
│   │   └── plugin.ts             # Pinia store for plugins
│   ├── layouts/
│   │   └── default.vue
│   ├── middleware/
│   │   └── auth.global.ts
│   └── assets/
│       └── css/
│           └── main.css
├── server/                       # Nitro server routes
│   ├── api/
│   │   ├── claude/
│   │   │   └── chat.post.ts      # Claude API proxy (keeps key server-side)
│   │   └── graph/
│   │       └── [...path].ts      # Graph API proxy with caching
│   └── middleware/
│       └── graph-auth.ts         # Inject Graph token into proxied requests
├── plugins/                      # Example plugins (copied to ~/.teamy/plugins on first run)
│   ├── notification-filter/
│   │   └── index.ts
│   ├── message-translator/
│   │   └── index.ts
│   └── unread-summarizer/
│       └── index.ts
├── types/
│   ├── graph.ts                  # MS Graph API response types
│   ├── plugin.ts                 # Plugin system types (TeamyPlugin, PluginContext)
│   └── claude.ts                 # Claude API types
├── nuxt.config.ts
├── app.config.ts                 # Nuxt UI theme customization
├── package.json
├── bunfig.toml
├── tsconfig.json
├── .env.example
└── TEAMY.md                      # This file
```

---

## Azure AD App Registration

1. Go to [Azure Portal](https://portal.azure.com) → Microsoft Entra ID → App Registrations → New
2. **Name:** Teamy
3. **Supported account types:** Accounts in this organizational directory only (single tenant)
4. **Platform:** Web
5. **Redirect URI:** `http://localhost:3000/auth/entra/callback`
6. **API permissions (delegated):**
   - `Chat.ReadWrite`
   - `ChannelMessage.Read.All`
   - `ChannelMessage.Send`
   - `Team.ReadBasic.All`
   - `Channel.ReadBasic.All`
   - `User.Read`
   - `Presence.Read`
   - `Presence.Read.All`
7. **Client secret:** Generate → copy to `.env`
8. **Token configuration:** Ensure `access_token` + `id_token` enabled

---

## Deep Link Formats

```
# 1:1 call
https://teams.microsoft.com/l/call/0/0?users={user_email}

# Join meeting
https://teams.microsoft.com/l/meetup-join/{meeting_id}

# Open chat in Teams web
https://teams.microsoft.com/l/chat/0/0?users={user_email}&message={optional_prefill}
```

---

## Performance Targets

| Metric | Target |
|--------|--------|
| RAM (idle, chat open) | < 80 MB |
| RAM (active, multiple chats) | < 120 MB |
| Cold start | < 2 seconds |
| Message send latency | < 500 ms |
| Binary size | < 15 MB |

---

## Implementation Order

```
Week 1:  WS1 (scaffold) → unblocks everything
         WS5 (Rust commands) — parallel, no frontend deps
Week 2:  WS2 (auth) + WS4 (UI with mock data)
Week 3:  WS3 (Graph API) + wire to WS4
Week 4:  WS6-A (Claude sidebar)
Week 5:  WS6-B+C (plugin system + generation)
Week 6:  Polish, example plugins, testing
```

---

## Claude Code Agent Team

Below are the prompts for running parallel Claude Code agents. Save this file as `TEAMY.md` in the repo root. Each agent reads this file for full context.

### How to Run

Open 4–6 terminal tabs. Start WS1 first, then launch others as dependencies are met.

### Agent Prompts

**Terminal 1 — WS1: Scaffold**
```
Read TEAMY.md carefully. Implement WS1 (Project Scaffold & Build Pipeline).

Initialize a Nuxt 4 project using Bun as the package manager. Add Nuxt UI v3, @nuxt/icon, and Pinia as modules. Initialize Tauri v2 inside the project. Configure tauri.conf.json for Bun commands with devUrl http://localhost:3000. Set up a basic macOS system tray icon and native menu bar. Verify the app launches with `bun run tauri dev`.

Tech: Nuxt 4, Nuxt UI v3, Tauri v2, Bun, TypeScript.
Output: Working app shell that opens a Nuxt UI page inside a Tauri window on macOS.
```

**Terminal 2 — WS5: Rust Backend**
```
Read TEAMY.md carefully. Implement WS5 (Native macOS Integration).

Create Tauri Rust commands for:
1. macOS notifications via tauri-plugin-notification (title, body, click handler)
2. Keychain storage via macOS Security framework (store/retrieve/delete)
3. Deep links — open URLs in default browser for Teams calls/meetings
4. System tray with dynamic unread count badge and right-click menu
5. Global shortcut Cmd+Shift+T to toggle window
6. Auto-launch on login via tauri-plugin-autostart

Create a frontend composable `app/composables/useTauri.ts` that wraps all invoke() calls with proper TypeScript types.

Tech: Rust, Tauri v2 plugins, TypeScript for the composable.
Output: All Tauri commands working and callable from the Nuxt frontend.
```

**Terminal 3 — WS2: Authentication**
```
Read TEAMY.md carefully. Implement WS2 (Authentication with nuxt-oidc-auth).

Install and configure nuxt-oidc-auth with the Entra ID provider. Set up:
1. nuxt.config.ts OIDC configuration with Entra provider (see WS2 in TEAMY.md for exact config)
2. .env.example with all required variables
3. Login page (app/pages/login.vue) using Nuxt UI components — UCard with login button
4. Global auth middleware (app/middleware/auth.global.ts) redirecting to /login if not authenticated
5. Composable useGraphToken() that extracts the access token from the OIDC session for Graph API usage
6. Logout functionality

Tech: nuxt-oidc-auth, Nuxt 4, Nuxt UI, TypeScript.
Output: Working login flow — user clicks login, redirects to Microsoft, comes back authenticated. useOidcAuth() and useGraphToken() composables available throughout the app.
```

**Terminal 4 — WS4: Chat UI**
```
Read TEAMY.md carefully. Implement WS4 (UI — Chat Interface).

Build the full chat UI using Nuxt UI v3 components. Start with MOCK DATA (hardcoded fake chats, messages, channels) so this can be developed in parallel with WS3.

Create:
1. Three-panel layout in layouts/default.vue (sidebar | messages | claude panel placeholder)
2. ChatList.vue — UList with avatar, name, preview, timestamp, unread UBadge. UInput for search.
3. MessageThread.vue — scrollable message list with MessageBubble.vue components
4. MessageBubble.vue — avatar, sender name, timestamp, message content (HTML safe), hover actions
5. ComposeBar.vue — UTextarea with auto-resize, Enter to send, UButton for send
6. ChannelList.vue — grouped by team, expandable sections
7. AppSidebar.vue — tabs for Chats and Channels, using UVerticalNavigation or UTabs
8. Command palette with UCommandPalette for Cmd+K quick switching
9. Settings page skeleton at pages/settings/index.vue
10. Dark/light mode via Nuxt UI useColorMode()

All data should come from composables that currently return mock data but have the same interface as the real Graph API composables defined in WS3. This makes wiring trivial later.

Design: Clean, minimal, native-feeling. No bloat. Use Nuxt UI's default theme with minor customization in app.config.ts. System font stack.

Tech: Nuxt 4, Nuxt UI v3, Vue 3 Composition API, TypeScript.
Output: Fully navigable chat UI with mock data. Beautiful, responsive, keyboard-accessible.
```

**Terminal 5 — WS3: Graph API** (start after WS2 auth is working)
```
Read TEAMY.md carefully. Implement WS3 (Graph API — Messaging Core).

Build the Graph API data layer:

1. composables/useGraph.ts — typed fetch wrapper that:
   - Gets token from useGraphToken() (from WS2)
   - Adds Authorization header
   - Handles pagination (@odata.nextLink)
   - Handles rate limiting (429 retry with backoff)
   - Handles Graph API error responses with typed errors

2. composables/useChats.ts — get chats, with last message preview via $expand
3. composables/useMessages.ts — get/send messages for a chat, with polling for new messages
4. composables/useChannels.ts — get joined teams and their channels, channel messages
5. composables/usePresence.ts — batch presence status with periodic refresh
6. composables/useSendMessage.ts — send to chat or channel

7. Pinia stores:
   - stores/chat.ts — chat list, active chat, unread counts
   - stores/channel.ts — teams, channels, active channel

8. Server API proxy (optional): server/api/graph/[...path].ts that forwards to Graph API with caching for team/channel lists

9. Types in types/graph.ts — full TypeScript types for Graph API responses (Chat, Message, Channel, Team, Presence, etc.)

All composables should have the SAME INTERFACE as the mock data composables from WS4 so wiring is a drop-in replacement.

Tech: Nuxt 4, Pinia, TypeScript, Microsoft Graph API v1.0.
Output: Complete data layer. When wired to WS4 UI, the app shows real Teams data.
```

**Terminal 6 — WS6: Claude + Plugins** (start after WS1 scaffold + WS3 basics work)
```
Read TEAMY.md carefully. Implement WS6 (Claude AI Integration & Plugin System).

Part A — Claude Sidebar:
1. components/claude/ClaudePanel.vue — right sidebar chat UI with Nuxt UI components
2. server/api/claude/chat.post.ts — server route proxying to Anthropic API (keeps key server-side), with SSE streaming
3. composables/useClaude.ts — manages conversation history, context injection, streaming state
4. System prompt includes: current chat context, installed plugins list, PluginContext API definition
5. Quick actions: /summarize, /draft, /translate, /plugin

Part B — Plugin Runtime:
1. types/plugin.ts — TeamyPlugin interface, PluginContext interface (see WS6 in TEAMY.md)
2. composables/usePlugins.ts — scans ~/.teamy/plugins/, dynamic import(), lifecycle management
3. stores/plugin.ts — Pinia store for installed plugins, enabled state
4. Plugin sandboxing — scoped context per plugin, no direct DOM access
5. Plugin settings persistence in ~/.teamy/plugins/{id}/data.json via Tauri fs commands

Part C — Example Plugins:
1. plugins/notification-filter/ — filter notifications by chat type and sender
2. plugins/message-translator/ — translate messages via Claude API
3. plugins/unread-summarizer/ — summarize unread messages on demand

Part D — Plugin Generation:
1. When user says "/plugin <description>", Claude generates plugin code
2. App saves to ~/.teamy/plugins/, reloads plugin list
3. Plugin manager UI at pages/settings/plugins.vue with UTable, enable/disable, logs

Tech: Nuxt 4, Nuxt UI, Anthropic Claude API, TypeScript, Tauri fs plugin.
Output: Working Claude sidebar that can chat, summarize messages, and generate functional plugins.
```

---

## Key Technical Decisions

| Decision | Rationale |
|----------|-----------|
| **Bun over Node** | Faster installs, native TS, built-in bundler |
| **Nuxt 4 over plain Vue** | File-based routing, auto-imports, server routes, modules ecosystem |
| **Nuxt UI over custom Tailwind** | 50+ accessible components, dark mode built-in, consistent design |
| **nuxt-oidc-auth over MSAL** | Native Nuxt module, built-in Entra provider, session management, PKCE |
| **Pinia over manual state** | Official Nuxt/Vue state management, devtools support, type-safe |
| **Tauri v2 over Electron** | WebKit not Chromium, 10x smaller binary, 5x less RAM |
| **Graph API REST over MS Graph SDK** | Less bloat, full control, typed manually |
| **Polling over webhooks for v1** | Simpler — webhooks need public endpoint. Optimize later. |
| **Server-side Claude proxy** | API key never exposed to frontend, rate limiting server-side |
| **Dynamic import() for plugins** | Standard ES modules, no custom VM needed |
